#!/usr/bin/env node

var defaults = {
    optimizeimages: false,
    debug: false,
    gzip: false,
    deferscripts: false,
    asyncscripts: false,
    stoponwarning: false,
    nocompress: false, // merge with --debug?
    less: true,
    cdnflash: true,
    cdnhtml: false,
    sharedbundles: false,
    manifest: false,
    negotiatemanifest: false,
    defaultlocale: 'en',
    localecookiename: 'locale',
    inlinesize: 8192
};

var optimist = require('optimist'),
    colors = require('colors'),
    commandLineOptions = optimist
        .usage('$0 --root <inputRootDirectory> --outroot <dir> [options] <htmlFile(s)>')
        .options('h', {
            alias: 'help',
            describe: 'Show this help',
            type: 'boolean',
            default: false
        })
        .options('root', {
            describe: 'Path to your web root (will be deduced from your input files if not specified)',
            type: 'string',
            demand: false
        })
        .options('outroot', {
            describe: 'Path to the output folder. Will be generated if non-existing',
            type: 'string',
            demand: false
        })
        .options('cdnroot', {
            describe: 'URI root where the static assets will be deployed. Must be either an absolute or a protocol-relative url',
            type: 'string',
            demand: false
        })
        .options('optimizeimages', {
            describe: 'Perform automatic lossless optimization of all images using pngcrush, pngquant, optipng, and jpegtran',
            type: 'boolean',
            default: defaults.optimizeimages
        })
        .options('debug', {
            describe: 'Keep statement level console.*() calls and debugger statements in JavaScript assets',
            type: 'boolean',
            default: defaults.debug
        })
        .options('version', {
            describe: 'Adds or updates <html data-version="..."> to the specified value. Use {0} to refer to the current value, eg. --version {0}/production or --version `git describe --long --tags --always --dirty 2>/dev/null || echo unknown`',
            type: 'string'
        })
        .options('gzip', {
            describe: 'Include a gzipped copy of text-based assets > 860 bytes for which it yields a saving',
            type: 'boolean',
            default: defaults.gzip
        })
        .options('deferscripts', {
            describe: 'Sets the "defer" attribute on all script tags',
            type: 'boolean',
            default: defaults.deferscripts
        })
        .options('asyncscripts', {
            describe: 'Sets the "async" attribute on all script tags',
            type: 'boolean',
            default: defaults.asyncscripts
        })
        .options('reservednames', {
            describe: 'Exclude certain variable names from mangling (equivalent to uglifyjs --reserved-names ...)'
        })
        .options('stoponwarning', {
            describe: 'Whether to stop with a non-zero exit code when a warning is encountered',
            type: 'boolean',
            default: defaults.stoponwarning
        })
        .options('nocompress', {
            describe: 'Prettifies HTML, CSS and Javascript for easier debugging',
            type: 'boolean',
            default: defaults.nocompress
        })
        .options('noless', {
            describe: 'Keep .less files as they are instead of automatically compiling them to CSS',
            type: 'boolean',
            default: !defaults.less
        })
        .options('nocdnflash', {
            describe: 'Avoid putting flash files on the cdnroot. Use this if you have problems setting up CORS',
            type: 'boolean',
            default: !defaults.cdnflash
        })
        .options('define', {
            alias: 'd',
            describe: '--define SYMBOL[=value] will be passed to UglifyJS as is (see the docs at https://github.com/mishoo/UglifyJS#usage). Remember to protect quotes from the shell, eg. --define foo=\\"bar\\"',
            type: 'string'
        })
        .options('inlinesize', {
            describe: 'Inline CSS backgrounds below this threshold as data-uris',
            default: defaults.inlinesize
        })
        .options('cdnhtml', {
            describe: 'Put non-initial HTML files on the cdnroot as well. Some CDN packages (such as Akamai\'s cheapest one) don\'t allow this',
            type: 'boolean',
            default: defaults.cdnhtml
        })
        .options('sharedbundles', {
            describe: 'Try to create shared bundles including commin files across multiple pages',
            type: 'boolean',
            default: defaults.sharedbundles
        })
        .options('manifest', {
            describe: 'Generates an appcache manifest file with all static assets included',
            type: 'boolean',
            default: defaults.manifest
        })
        .options('negotiatemanifest', {
            describe: 'Removes the locale id from the <html manifest="..."> references so all manifests are assumed to be accessible from the same url. Useful if you want the browser to pick up the right cache manifest and HTML after a locale change (your static file server needs to support content negotiation). Only makes sense when both  --manifest and --locale have been specified',
            type: 'boolean',
            default: defaults.negotiatemanifest
        })
        .options('locales', {
            describe: 'Comma-separated list of locales to build seperate versions for',
            type: 'string',
            demand: false
        })
        .options('defaultlocale', {
            describe: 'The locale of the default value in TR statements and tags with a data-i18n attribute',
            type: 'string',
            default: defaults.defaultlocale
        })
        .options('localecookiename', {
            describe: 'The name of your locale cookie (exposed as LOCALECOOKIENAME)',
            type: 'string',
            default: defaults.localecookiename
        })
        .options('repl', {
            describe: 'Start the REPL after a particular transform (or "error")',
            type: 'string'
        })
        /*
        // These are internal One.com options. No reason to expose them to the world.
        // Might be deprecated in the near future. If in doubt, don't use!
        .options('label', {
            describe: 'Registers labels as custom protocols for path resolving. You can create multiple of these: --label <labelName>=<dir> --label <otherLabelName>=<otherDir>',
            type: 'string',
            demand: false
        })
        .options('parentdir', {
            describe: 'If an unknown label (scheme) is found, look for at parent dir of that name before failing (breaks custom protocols)',
            type: 'boolean',
            demand: false
        })
        */
        .check(function (argv) {
            return typeof argv.inlinesize === 'number';
        })
        .wrap(72)
        .argv;


if (commandLineOptions.h) {
    optimist.showHelp();
    process.exit(1);
}

// Temporary deprecation message
if (commandLineOptions.less) {
    console.warn('INFO: The --less command line option is deprecated. This is now default behavior. Use --noless to keep .less files in build output'.yellow);
}

// Temporary deprecation message
if (commandLineOptions.stripdebug) {
    console.warn('INFO: the --stripdebug switch is deprecated. This behavior is now default. Use --debug to keep debugging in build output'.yellow);
}

// Temporary deprecation message
if (commandLineOptions.cdnflash) {
    console.warn('INFO: the --cdnflash switch is deprecated. This is now default functionality. Use --nocdnflash to get the old default behavior.'.yellow);
}

// Temporary deprecation message
if (commandLineOptions.cdnoutroot) {
    console.warn('INFO: the --cdnoutroot switch is deprecated. Default location for your cdn assets is now <outroot>/static/cdn'.yellow);
}

var util = require('util'),
    AssetGraph = require('../lib/AssetGraph'),
    uglifyJs = AssetGraph.JavaScript.uglifyJs,
    uglifyAst = AssetGraph.JavaScript.uglifyAst,
    defines = {},
    _ = require('underscore'),
    dotfile = require('dotfile'),
    configfile = dotfile('assetgraph', {
        dirname: '.'
    });

(commandLineOptions.define ? _.flatten(_.flatten([commandLineOptions.define])) : []).forEach(function (define) {
    var matchDefine = define.match(/^(\w+)(?:=(.*))?$/);
    if (matchDefine) {
        var valueAst;
        if (matchDefine[2]) {
            try {
                valueAst = uglifyAst.parseExpression(matchDefine[2]);
            } catch (e) {
                console.error('Invalid --define ' + matchDefine[1] + ': Could not parse ' + matchDefine[2] + ' as a JavaScript expression. Missing shell escapes?');
                console.error(e.message + ' (line ' + e.line + ', column ' + e.col + ')');
                process.exit(1);
            }
        } else {
            valueAst = new uglifyJs.AST_True();
        }
        defines[matchDefine[1]] = valueAst;
    }
});



configfile.exists(function (exists) {
    function handleConfig (err, config) {
        if (err) {
            throw new Error('Error reading configuration file: ' + err.message);
        } else {
            config = _.defaults(config, defaults);

            // File paths in config are root relative. Normalize to file system paths
            if (config.root && Array.isArray(config.files)) {
                config.files = config.files.map(function (filePath) {
                    return config.root + '/' + filePath;
                });
            }

            run(config);
        }
    }

    if (exists) {
        console.warn('Read configuration from ' + configfile.filepath);
        configfile.read(handleConfig);
    } else {
        configfile = dotfile('assetgraph');

        configfile.exists(function (exists) {
            if (exists) {
                console.warn('Read configuration from ' + configfile.filepath);
                configfile.read(handleConfig);
            } else {
                configfile = dotfile('assetgraph', {
                    dirname: dotfile._tilde + '/.config/'
                });

                configfile.exists(function (exists) {
                    if (exists) {
                        console.warn('Read configuration from ' + configfile.filepath);
                        configfile.read(handleConfig);
                    } else {
                        console.warn('No configuration file found');
                        run();
                    }
                })
            }
        })
    }
});

function run (config) {
    config = config || defaults;
    // Normalize command line options
    commandLineOptions.less = !commandLineOptions.noless;
    commandLineOptions.cdnflash = !commandLineOptions.nocdnflash;

    // Only overriconfig with commandLineOptions if commandLineOptions differ from defaults.
    // This means you can't override a configuration from the config file with a command line option equal to the default value.
    // Caused by optimist setting the default value . We most likely need to revisit this, and maybe even stop using optimist here.
    Object.keys(commandLineOptions).forEach(function (key) {
        if (defaults[key] !== commandLineOptions[key]) {
            config[key] = commandLineOptions[key];
        }
    });

    if (!config.outroot) {
        console.error('Missing required arguments: outroot');
        process.exit(1);
    }

    // If any files are added fromt he command line any files from the config files are completely replaced
    if (commandLineOptions._.length > 0) {
        config.files = commandLineOptions._;
    } else if (!Array.isArray(config.files)) {
        config.files = [];
    }

    var i18nTools = require('../lib/i18nTools'),
        query = AssetGraph.query,
        urlTools = require('assetgraph/lib/util/urlTools'),

        rootUrl = config.root && urlTools.urlOrFsPathToUrl(config.root, true),
        outRoot = urlTools.fsDirToFileUrl(config.outroot),
        cdnRoot = config.cdnroot && urlTools.ensureTrailingSlash(config.cdnroot),
        fullCdnRoot = (/^\/\//.test(cdnRoot) ? 'http:' : '') + cdnRoot,
        localeIds = config.locales && _.flatten(_.flatten([configlocales]).map(function (localeId) {
            return localeId.split(",");
        })).map(i18nTools.normalizeLocaleId),
        reservedNames = config.reservednames && _.flatten(_.flatten([config.reservednames]).map(function (reservedName) {
            return reservedName.split(",");
        })),
        defaultLocaleId = config.defaultlocale && i18nTools.normalizeLocaleId(config.defaultlocale),
        localizationInfoObject = {},
        inputUrls;

    if (config.files.length > 0) {
        inputUrls = config.files.map(function (urlOrFsPath) {
            return urlTools.urlOrFsPathToUrl(urlOrFsPath, false);
        });
        if (!rootUrl) {
            rootUrl = urlTools.findCommonUrlPrefix(inputUrls.filter(function (inputUrl) {
                return /^file:/.test(inputUrl);
            }));
            if (rootUrl) {
                console.warn("Guessing --root from input files: " + rootUrl);
            }
        }
    } else if (rootUrl && /^file:/.test(rootUrl)) {
        inputUrls = [rootUrl + '**/*.html'];
        console.warn('No input files specified, defaulting to ' + inputUrls[0]);
    } else {
        throw new Error("No input files and no --root specified (or it isn't file:), cannot proceed");
    }

    var startReplRegExp;
    if (config.repl) {
        startReplRegExp = new RegExp(_.flatten(_.flatten([config.repl]).map(function (transformName) {
            return transformName.split(",");
        })).map(function (transformName) {
            return transformName.replace(/[\.\+\{\}\[\]\(\)\?\^\$]/g, '\\$&');
        }).join('|'));
    }

    new AssetGraph({root: rootUrl})
        .on('afterTransform', function (transform, elapsedTime) {
            console.log(' ✔ '.green + (elapsedTime / 1000).toFixed(3) + " secs: " + transform.name);
            if (startReplRegExp && startReplRegExp.test(transform.name)) {
                this.transformQueue.transforms.unshift(AssetGraph.transforms.startRepl());
            }
        })
        .on('warn', function (err) {
            // These are way too noisy
            if (err.relationType !== 'JavaScriptCommonJsRequire') {
                console.warn((' ⚠ ' + (err.asset ? err.asset.urlOrDescription + ': ' : '') + err.message).yellow);
                if (startReplRegExp && startReplRegExp.test('warn')) {
                    this.transformQueue.transforms.unshift(AssetGraph.transforms.startRepl());
                } else if (config.stoponwarning) {
                    process.exit(1);
                }
            }
        })
        .on('error', function (err) {
            console.error((' ✘ ' + (err.asset ? err.asset.urlOrDescription + ': ' : '') + err.stack).red);
            if (startReplRegExp && startReplRegExp.test('error')) {
                this.transformQueue.transforms.unshift(AssetGraph.transforms.startRepl());
            } else {
                process.exit(1);
            }
        })
        .registerRequireJsConfig({preventPopulationOfJavaScriptAssetsUntilConfigHasBeenFound: true})
        .registerLabelsAsCustomProtocols(config.label, {installFindParentDirectoryAsDefault: config.parentdir})
        .loadAssets(inputUrls)
        .buildProduction({
            version: config.version,
            less: config.less,
            optimizeImages: config.optimizeimages,
            inlineSize: config.inlinesize,
            gzip: config.gzip,
            defines: defines,
            reservedNames: reservedNames,
            localeIds: localeIds,
            localeCookieName: config.localecookiename,
            localizationInfoObject: localizationInfoObject,
            defaultLocaleId: defaultLocaleId,
            manifest: config.manifest,
            negotiateManifest: config.negotiatemanifest,
            asyncScripts: config.asyncscripts,
            deferScripts: config.deferscripts,
            cdnRoot: cdnRoot,
            cdnFlash: config.cdnflash,
            cdnHtml: config.cdnhtml,
            noCompress: config.nocompress,
            sharedBundles: config.sharedbundles,
            stripDebug: !config.debug
        })
        .writeAssetsToDisc({url: /^file:/, isLoaded: true}, outRoot)
        .if(cdnRoot)
            .writeAssetsToDisc({url: query.createPrefixMatcher(fullCdnRoot), isLoaded: true}, outRoot + 'static/cdn/', fullCdnRoot)
        .endif()
        .writeStatsToStderr()
        .run(function (err) {
            if (err) {
                throw err;
            }
            if (localeIds) {
                var missingKeys = Object.keys(localizationInfoObject.localeIdsByMissingKey || {});
                if (missingKeys.length > 0) {
                    console.warn('The following keys were missing:\n  ' + missingKeys.map(function (missingKey) {
                        return missingKey + ' (' + localizationInfoObject.localeIdsByMissingKey[missingKey].join(',') + ')';
                    }).join('\n  '));
                }

                var defaultValueMismatchKeys = Object.keys(localizationInfoObject.defaultValueMismatchesByKey || {});
                if (defaultValueMismatchKeys.length > 0) {
                    console.warn('The following keys had mismatching default and/or ' + defaultLocaleId + ' values:\n  ' + defaultValueMismatchKeys.map(function (defaultValueMismatchKey) {
                        return defaultValueMismatchKey + ':\n    ' + util.inspect(localizationInfoObject.defaultValueMismatchesByKey[defaultValueMismatchKey], false, 99);
                    }).join('\n  '));
                }
                var whitespaceWarningKeys = Object.keys(localizationInfoObject.whitespaceWarningsByKey || {});
                if (whitespaceWarningKeys.length > 0) {
                    console.warn('The following keys had leading or trailing whitespace:\n  ' + whitespaceWarningKeys.map(function (whitespaceWarningKey) {
                        return whitespaceWarningKey + ':\n    ' + util.inspect(localizationInfoObject.whitespaceWarningsByKey[whitespaceWarningKey], false, 99);
                    }).join('\n  '));
                }
            }
        });
}
